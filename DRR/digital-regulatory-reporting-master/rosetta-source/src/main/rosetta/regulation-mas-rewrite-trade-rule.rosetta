namespace drr.regulation.mas.rewrite.trade
version "${project.version}"

import cdm.base.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.qualification.*
import cdm.event.workflow.*
import cdm.product.collateral.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*

import drr.regulation.common.*
import drr.regulation.common.util.*
import drr.regulation.mas.*
import drr.standards.iosco.cde.*
import drr.standards.iso.*

import iso20022.auth030.mas.*

corpus Dissemination Trade

report MAS Trade in T+1
  	from TransactionReportInstruction
  	when ReportableProduct
  	with type MASTransactionReport

//eligibility rules
eligibility rule ReportableProduct from TransactionReportInstruction:
    [regulatoryReference MAS Trade
        provision "Demonstrative eligibility rule for display"]
    True

//reporting rules
reporting rule Counterparty1 from TransactionReportInstruction: <"Counterparty 1">
    [regulatoryReference MAS Trade dataElement "1" field "Counterparty 1"
        provision "Identifier of Counterparty 1."]
    extract CDECounterparty1
        as "1 Counterparty 1"

reporting rule Counterparty2 from TransactionReportInstruction: <"Counterparty 2">
    [regulatoryReference MAS Trade dataElement "2" field "Counterparty 2"
        provision "Identifier of Counterparty 2"]
    extract CDECounterparty2
        as "2 Counterparty 2"

reporting rule Counterparty2IdentifierType from TransactionReportInstruction: <"Counterparty 2 Identifier Type">
    [regulatoryReference MAS Trade dataElement "3" field "Counterparty 2 Identifier Type"
        provision "Indicator of whether LEI (including pre-LEI) was used to identify Counterparty 2."]
    extract reportInstruction [
        extract
            if TradeForEvent(reportInstruction) -> tradableProduct -> counterparty -> partyReference exists
                then TradeForEvent(reportInstruction) -> tradableProduct -> counterparty -> partyReference
                else if PositionForEvent(reportInstruction) -> positionBase -> counterparty -> partyReference exists
                then PositionForEvent(reportInstruction) -> positionBase -> counterparty -> partyReference
        then filter item = reportInstruction -> reportingSide -> reportingCounterparty
        then only-element
        then extract
            if person exists
                    and person -> personId -> identifierType any = PersonIdentifierTypeEnum -> NPID
            then False
            else if partyId -> identifierType any = PartyIdentifierTypeEnum -> LEI
                    and person is absent
            then True
    ]
        as "3 Counterparty 2 Identifier Type"

reporting rule TradingCapacityOfSpecifiedPerson from TransactionReportInstruction: <"Trading Capacity Of Specified Person">
    [regulatoryReference MAS Trade dataElement "4" field "TradingCapacityOfSpecifiedPerson"
        provision "To denote trading capacity of specified person. "]
    filter IsAllowableAction
    then extract reportInstruction [
            reportableInformation -> partyInformation
                then filter
                    partyReference = reportInstruction -> reportingSide -> reportingParty
                then extract regimeInformation
                then flatten
                then filter supervisoryBody = SupervisoryBodyEnum -> MAS
                then only-element
                then extract if reportingRole = ReportingRoleEnum -> Agent then "Agent"
                else if reportingRole = ReportingRoleEnum -> Principal then "Principal"
        ] 
        as "4 Trading Capacity Of Specified Person"

reporting rule Direction from TransactionReportInstruction: <"Direction">
    [regulatoryReference MAS Trade dataElement "5" field "Direction"
        provision "Indicator of whether Counterparty 1 is the buyer or the seller in the contract, where applicable."]
    /*
     * 4 alphabetic characters:
     * 	BYER = buyer
     * 	SLLR = seller
     */
    filter IsAllowableAction
    then extract CDEDirection1
        as "5 Direction"

reporting rule DirectionOfLeg1 from TransactionReportInstruction: <"Direction of leg 1">
    [regulatoryReference MAS Trade dataElement "6" field "Direction of leg 1"
        provision "Indicator of whether Counterparty 1 is the payer or the receiver of leg 1 in the contract, where applicable."]
    /*
     * 4 alphabetic characters:
     * 	MAKE = payer
     * 	TAKE = receiver
     */
    filter IsAllowableAction
    then extract
        CDEDirection2(
                item,
                TradeForEvent
                    extract trade [
                        trade -> tradableProduct -> product
                            extract
                                if IsCommoditySwapFloatFloat
                                then CommodityLeg1 -> payerReceiver
                                else if IsCommoditySwapFixedFloat
                                then FixedPriceLeg1 -> payerReceiver
                                else if IsEquity and ((IsVarianceSwap or IsVolatilitySwap) = False)
                                then contractualProduct -> economicTerms -> payout -> performancePayout only-element -> payerReceiver
                                else if IsFXForward
                                 then FXLeg1(ProductForTrade(trade)) -> payerReceiver
                                else if Qualify_InterestRate_Option_Swaption(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_InterestRate_CapFloor(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_AssetClass_Credit(
                                                contractualProduct -> economicTerms
                                            ) = False
                                then InterestRateLeg1 -> payerReceiver
                    ]
            )
        as "6 Direction of leg 1"

reporting rule DirectionOfLeg2 from TransactionReportInstruction: <"Direction of leg 2">
    [regulatoryReference MAS Trade dataElement "7" field "Direction of leg 2"
        provision "Indicator of whether Counterparty 1 is the payer or the receiver of leg 2 in the contract, where applicable."]
    /*
     * 4 alphabetic characters:
     * 	MAKE = payer
     * 	TAKE = receiver
     */
    filter IsAllowableAction
    then extract
        CDEDirection2(
                item,
                TradeForEvent -> tradableProduct -> product
                            then extract
                                if IsCommoditySwap
                                then CommodityLeg2 -> payerReceiver
                                else if IsEquity and ((IsVarianceSwap or IsVolatilitySwap) = False)
                                then
                                    (
                                    if InterestRateLeg2 exists then
                                        InterestRateLeg2 -> payerReceiver
                                    else if contractualProduct -> economicTerms -> payout -> fixedPricePayout exists then
                                        contractualProduct -> economicTerms -> payout -> fixedPricePayout -> payerReceiver distinct only-element
                                    )
                                else if IsFXForward
                                then FXLeg2 -> payerReceiver
                                else if Qualify_InterestRate_Option_Swaption(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_InterestRate_CapFloor(
                                                contractualProduct -> economicTerms
                                            ) = False
                                        and Qualify_AssetClass_Credit(
                                                contractualProduct -> economicTerms
                                            ) = False
                                then InterestRateLeg2 -> payerReceiver
            )
        as "7 Direction of leg 2"

reporting rule ReportingSpecifiedPerson from TransactionReportInstruction: <"Reporting specified person">
    [regulatoryReference MAS Trade dataElement "8" field "Reporting specified person"
        provision "Identifier of the specified person with the reporting obligation in respect of the contract."]
    extract ExtractPartyResponsibleForReportingIdentifier(reportingSide)
        as "8 Reporting specified person"

reporting rule DataSubmitter from TransactionReportInstruction: <"Data submitter">
    [regulatoryReference MAS Trade dataElement "9" field "Data submitter"
        provision "Identifier of the entity submitting information on the contract, which is reported to a licensed trade repository or licensed foreign trade repository."]
    extract ExtractReportSubmittingPartyIdentifier(reportingSide)
        as "9 Data submitter"

reporting rule MASUniqueTransactionIdentifier from TransactionReportInstruction: <"Unique Transaction Identifier (UTI)">
    [regulatoryReference MAS Trade dataElement "10" field "Unique Transaction Identifier (UTI)"
        provision "Unique identifier to denote the contract."]
    extract
        if GetRegimeSpecificIdentifiers(reportableInformation, SupervisoryBodyEnum -> MAS, TradeIdentifierTypeEnum -> UniqueTransactionIdentifier) exists
        then GetRegimeSpecificIdentifiers(reportableInformation, SupervisoryBodyEnum -> MAS, TradeIdentifierTypeEnum -> UniqueTransactionIdentifier)
        else if TradeForEvent exists
        then (TradeForEvent -> tradeIdentifier
            filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then assignedIdentifier -> identifier)
        else if PositionForEvent exists
        then (PositionForEvent -> positionIdentifier
            filter identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then assignedIdentifier -> identifier)
    then distinct
    then only-element

reporting rule UniqueTransactionIdentifier from TransactionReportInstruction: <"Unique Transaction Identifier (UTI)">
    [regulatoryReference MAS Trade dataElement "10" field "Unique Transaction Identifier (UTI)"
        provision "Unique identifier to denote the contract."]
    MASUniqueTransactionIdentifier
    then filter StringContains(item, "^[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}$") = True
        as "10 Unique Transaction Identifier (UTI)"

reporting rule UniqueTransactionIdentifierProprietary from TransactionReportInstruction: <"Unique Transaction Identifier (UTI)">
    [regulatoryReference MAS Trade dataElement "10" field "Unique Transaction Identifier (UTI)"
        provision "Unique identifier to denote the contract."]
    MASUniqueTransactionIdentifier
    then filter StringContains(item, "^[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}$") = False
        as "10 Unique Transaction Identifier (Proprietary)"

reporting rule UniqueProductIdentifier from TransactionReportInstruction: <"Unique product identifier (UPI)">
    [regulatoryReference MAS Trade dataElement "11" field "Unique product identifier (UPI)"
        provision "An identifier to denote the product type."]
    filter IsAllowableAction or IsActionTypeTERM or IsActionTypeEROR
    then extract TradeForEvent
    then extract tradableProduct -> product -> contractualProduct -> productIdentifier
    then filter source = ProductIdTypeEnum -> UPI
    then only-element
    then extract identifier
        as "11 Unique product identifier (UPI)"

reporting rule PriorUTI from TransactionReportInstruction: <"Prior UTI">
    [regulatoryReference MAS Trade dataElement "12" field "Prior UTI"
        provision "To denote the previous UTI that immediately precedes the UTI that relates to this contract, where applicable."]
    filter IsAllowableAction
    then if TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False
            then extract CDEPriorUTI
        else (extract reportableInformation -> transactionInformation
            then filter
                regimeName = RegimeNameEnum -> MAS and priorTransactionIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then extract priorTransactionIdentifier -> assignedIdentifier -> identifier
            then flatten
            then distinct
            then only-element)
    then filter StringContains(item, "^[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}$") = True
        as "12 Prior UTI"

reporting rule PriorUTIProprietary from TransactionReportInstruction: <"Prior UTI (Proprietary)">
    [regulatoryReference MAS Trade dataElement "12" field "Prior UTI"
        provision "To denote the previous UTI that immediately precedes the UTI that relates to this contract, where applicable."]
    filter IsAllowableAction
    then if TradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier <> BeforeTradeForEvent -> tradeIdentifier -> assignedIdentifier -> identifier
                and Qualify_Compression(originatingWorkflowStep -> businessEvent) = False
            then extract CDEPriorUTI
        else (extract reportableInformation -> transactionInformation
            then filter
                regimeName = RegimeNameEnum -> MAS and priorTransactionIdentifier -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then extract priorTransactionIdentifier -> assignedIdentifier -> identifier
            then flatten
            then distinct
            then only-element)
    then filter StringContains(item, "^[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}$") = False
        as "12 Prior UTI (Proprietary)"

reporting rule ContractType from TransactionReportInstruction: <"Contract Type">
    [regulatoryReference MAS Trade dataElement "13" field "Contract type"
        provision "To denote the contract type of the derivatives contract."]
    filter IsAllowableAction or IsActionTypeTERM or IsActionTypeEROR
    then extract ProductForEvent
    then extract
        if IsFRA
        then "FRAS"
        else if Qualify_ForeignExchange_Spot_Forward(contractualProduct -> economicTerms)
                or // this is going to need additional date treatments to distinguish spot vs forward per ESMA rules
                Qualify_ForeignExchange_NDF(contractualProduct -> economicTerms)
        // this needs to be extended to cover other types of Forwards (e.g. Commodity, Equity, Bond) once the CDM contains suitable examples
        then "FORW"
        else if IsIRSwaption or IsCreditSwaption or IsCommoditySwaption
        then "SWPT"
        else if Qualify_InterestRate_CapFloor(EconomicTermsForProduct)
                or EconomicTermsForProduct -> payout -> optionPayout only exists
        then "OPTN"
        else if Qualify_BaseProduct_IRSwap(EconomicTermsForProduct)
                or Qualify_BaseProduct_Inflation(EconomicTermsForProduct)
                or Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct)
                or Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year(
                        EconomicTermsForProduct
                    )
                or Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(
                        EconomicTermsForProduct
                    )
                or Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(
                        EconomicTermsForProduct
                    )
                or Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon(
                        EconomicTermsForProduct
                    )
                or Qualify_AssetClass_Credit(EconomicTermsForProduct)
                or Qualify_BaseProduct_EquitySwap(EconomicTermsForProduct)
                or Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct)
                or Qualify_Commodity_Swap_Basis(EconomicTermsForProduct)
                or // Commodity will need to be refined once further product types are added to the model, possible scope for an AssetClass qualification rule
                Qualify_ForeignExchange_Swap(EconomicTermsForProduct)
                or EconomicTermsForProduct -> payout -> performancePayout only exists // TH Review: what does only 1 performancePayout describe?
        then "SWAP"
        else "OTHR"
        as "13 Contract Type"

reporting rule AssetClass from TransactionReportInstruction: <"Asset Class">
    [regulatoryReference MAS Trade dataElement "14" field "Asset class"
        provision "To denote the asset class of the derivatives contract."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract EconomicTermsForProduct
    then extract
        if Qualify_AssetClass_InterestRate
        then "INTR"
        else if Qualify_AssetClass_Credit
        then "CRDT"
        else if Qualify_AssetClass_Equity
        then "EQUI"
        else if Qualify_AssetClass_Commodity
        then "COMM"
        else if Qualify_AssetClass_ForeignExchange
        then "CURR"
        as "14 Asset Class"

reporting rule Underlying from TransactionReportInstruction: <"Underlying">
    [regulatoryReference MAS Trade dataElement "14" field "Underlying"
        provision "An identifier for the underlying thing to the contract, where applicable."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        // Underlying Identification Type = I for ISIN
        if UnderlierForProduct -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if UnderlierForProduct -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and UnderlierForProduct -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (UnderlierForProduct -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
       else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        // Underlying Identification Type = X for Index
        else if UnderlierForProduct -> index exists
        then UnderlierForProduct -> index -> productIdentifier -> identifier
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index exists
        then EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index -> productIdentifier -> identifier
        else if EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index exists
        then EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index -> productIdentifier -> identifier
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId
        else if IsFRA
        then  EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification ->
        floatingRate -> rateOption -> indexReferenceInformation -> indexId
        //Underlying Identification Type = B
        else if UnderlierForProduct -> basket exists
        then UnderlierForProduct -> basket -> productIdentifier -> identifier
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> basket exists
        then EconomicTermsForProduct -> payout -> performancePayout -> underlier -> basket -> productIdentifier -> identifier
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> basketId
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> basketId
    then last // cardinality mismatch - see DRR ISSUE-624
        as "15 Underlying"

reporting rule UnderlyingIdentificationTypeDTCC from TransactionReportInstruction: <"Underlying Identification Type (DTCC)">
    [regulatoryReference MAS Trade dataElement "15" field "Underlying Identification Type (DTCC)"
        provision "An identifier for the underlying thing to the contract, where applicable."]
    [regulatoryReference ISDA PeerReviewGroup date "20230426"
        provision "Regarding test samples of Equity baskets with a single index or a single security with an ISIN, the view of Credit Suisse's representative is that those samples are valid because they illustrate an acceptable boundary condition."]
    filter IsAllowableAction
    then extract
        if GetUnderlyingIdentificationType exists
        then GetUnderlyingIdentificationType
        else if Qualify_AssetClass_ForeignExchange(EconomicTermsForProduct(ProductForEvent)) = False then "O"
        as "15.2 Underlying Identification Type (DTCC)"

reporting rule UnderlyingIdOtherDTCC from TransactionReportInstruction: <"Underlying ID (Other) (DTCC)">
    [regulatoryReference MAS Trade dataElement "15" field "Underlying ID (Other) (DTCC)"
        provision "An identifier for the underlying thing to the contract, where applicable."]
    filter IsAllowableAction and Qualify_AssetClass_ForeignExchange(EconomicTermsForProduct(ProductForEvent)) = False
    then extract ProductForEvent
    then extract
        // Underlying Identification Type different to ISIN
        if UnderlierForProduct -> security -> productIdentifier exists and UnderlierForProduct -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then identifier)
        else if UnderlierForProduct -> loan -> productIdentifier exists and UnderlierForProduct -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and UnderlierForProduct -> commodity -> productIdentifier exists and UnderlierForProduct -> commodity -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN)
        then (UnderlierForProduct -> commodity -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier exists and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier exists and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier exists and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier exists and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier exists and EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier exists and EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier exists and EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
       else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier exists and EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract identifier)
        as "15.3 Underlying ID (Other) (DTCC)"

reporting rule UnderlyingIdOtherSourceDTCC from TransactionReportInstruction: <"Underlying ID (Other) Source (DTCC)">
    [regulatoryReference MAS Trade dataElement "15" field "Underlying ID (Other) Source (DTCC)"
        provision "An identifier for the underlying thing to the contract, where applicable."]
    filter IsAllowableAction and Qualify_AssetClass_ForeignExchange(EconomicTermsForProduct(ProductForEvent)) = False
    then extract ProductForEvent
    then extract
        // Underlying Identification Type different to ISIN
        if UnderlierForProduct -> security -> productIdentifier exists and UnderlierForProduct -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then source)
        else if UnderlierForProduct -> loan -> productIdentifier exists and UnderlierForProduct -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (UnderlierForProduct -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if (IsProductETD and UnderlierForProduct -> commodity -> productIdentifier exists and UnderlierForProduct -> commodity -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN)
        then (UnderlierForProduct -> commodity -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier exists and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier exists and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier exists and EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> commodity -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier exists and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier exists and EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier exists and EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier exists and EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
       else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier exists and EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source all <> ProductIdTypeEnum -> ISIN
        then (EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
            filter source <> ProductIdTypeEnum -> ISIN
            then first
            then extract source)
       // cardinality mismatch - see DRR ISSUE-624
        as "15.4 Underlying ID (Other) Source (DTCC)"

reporting rule NameOfTheUnderlyingIndexDTCC from TransactionReportInstruction: <"Name of the underlying index (DTCC)">
    [regulatoryReference MAS Trade dataElement "15" field "Name of the underlying index (DTCC)"
        provision "An identifier for the underlying thing to the contract, where applicable."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
        then EconomicTermsForProduct(UnderlierForProduct) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if UnderlierForProduct -> index exists
                and UnderlierForProduct -> index -> productIdentifier -> source any = ProductIdTypeEnum -> Name
        then (UnderlierForProduct -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index exists
        then (EconomicTermsForProduct -> payout -> performancePayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        // Commodities: only for ETDs
        else if (IsProductETD and EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index exists and IsSingleCommodityPayoutProduct = False)
        then (EconomicTermsForProduct -> payout -> commodityPayout -> underlier -> index -> productIdentifier
            then filter source = ProductIdTypeEnum -> Name
            then extract identifier)
        else if IsFRA
        then EconomicTermsForProduct -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexName
            first
            to-string then first
        as "15.5 Name of the underlying index (DTCC)"

reporting rule FixedRateOfLeg1 from TransactionReportInstruction: <"Fixed rate of leg 1">
    [regulatoryReference MAS Trade dataElement "16" field "Fixed rate of leg 1"
        provision "Per annum rate of the fixed rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract CDEInterestRateFixedRate(InterestRateLeg1) * 100
        as "16 Fixed Rate of leg 1 or coupon"

reporting rule IdentifierOfFloatingRateOfLeg1 from TransactionReportInstruction:
    [regulatoryReference MAS Trade dataElement "17" field "Identifier of the floating rate of leg 1"
        provision "Identifier of the rate used for leg 1 which are reset at predetermined intervals by reference to a market reference rate, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract RateOption
    then extract item -> indexReferenceInformation -> indexId only-element
        as "17 Identifier of the floating rate of leg 1"

reporting rule NameOfTheFloatingRateOfLeg1 from TransactionReportInstruction: <"Name of the Floating Rate of Leg 1">
    [regulatoryReference MAS Trade dataElement "18" field "Name of the Floating Rate of Leg 1"
        provision "Name of the rate used for leg 1 which are reset at predetermined intervals by reference to a market reference rate, where 'Identifier of the floating rate of leg 1' is not available."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract GetNameOfTheFloatingRateOfLeg1
        as "18 Name of the Floating Rate of Leg 1"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule SpreadOfLeg1Monetary from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference MAS Trade dataElement "19" field "Spread of Leg 1"
        provision "For leg 1 of the contract, where applicable, the spread on the floating rate index reference price of leg 1, or the difference between the reference prices of two floating rate indexes."]
    filter IsAllowableAction
    then extract CDESpreadLeg1
    then extract
        if GetPriceNotation = PriceNotationEnum -> Monetary
        then MultiplyPrice(value, GetPriceNotation)
        as "19 Spread of Leg 1 (Monetary)"

reporting rule SpreadOfLeg1Decimal from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference MAS Trade dataElement "19" field "Spread of Leg 1"
        provision "For leg 1 of the contract, where applicable, the spread on the floating rate index reference price of leg 1, or the difference between the reference prices of two floating rate indexes."]
    filter IsAllowableAction
    then extract CDESpreadLeg1
    then extract
        if (GetPriceNotation = PriceNotationEnum -> Percentage or GetPriceNotation = PriceNotationEnum -> Decimal)
        then MultiplyPrice(value, PriceNotationEnum -> Decimal)
        as "19 Spread of Leg 1 (Percentage)"

reporting rule SpreadOfLeg1Basis from TransactionReportInstruction: <"Spread of Leg 1">
    [regulatoryReference MAS Trade dataElement "19" field "Spread of Leg 1"
        provision "For leg 1 of the contract, where applicable, the spread on the floating rate index reference price of leg 1, or the difference between the reference prices of two floating rate indexes."]
    filter IsAllowableAction
    then extract CDESpreadLeg1
    then extract
        if GetPriceNotation = PriceNotationEnum -> Basis
        then MultiplyPrice(value, GetPriceNotation)
        as "19 Spread of Leg 1 (Basis)"

reporting rule SpreadNotationOfLeg1 from TransactionReportInstruction: <"Spread Notation of Leg 1">
    [regulatoryReference MAS Trade dataElement "20" field "Spread Notation of Leg 1"
        provision "Manner in which Spread of leg 1 is expressed, where applicable."]
    filter IsAllowableAction
    then if CDESpreadLeg1NotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else CDESpreadLeg1NotationEnum
        as "19 Spread Notation of Leg 1"

reporting rule SpreadCurrencyOfLeg1 from TransactionReportInstruction: <"Spread Currency of Leg 1">
    [regulatoryReference MAS Trade dataElement "21" dataElement "94" field "Spread Currency of Leg 1"
        provision "Where applicable: currency in which the spread of leg 1 is denominated. This data element is only applicable if spread is expressed as monetary amount."]
    filter IsAllowableAction
    then extract CDESpreadLeg1Currency
        as "2.94 Spread Currency of Leg 1"

/* ---------------------------------------------------------------------------------------------------------------- */
reporting rule FixedRateOfLeg2 from TransactionReportInstruction: <"Fixed rate of leg 2">
    [regulatoryReference MAS Trade dataElement "22" field "Fixed rate of leg 2"
        provision "Per annum rate of the fixed rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract if IsFRA then CDEInterestRateFixedRate(InterestRateLeg1) * 100
    else CDEInterestRateFixedRate(InterestRateLeg2) * 100
        as "22 Fixed Rate of leg 2"

reporting rule IdentifierOfFloatingRateOfLeg2 from TransactionReportInstruction: <"Identifier of the floating rate of leg 2">
    [regulatoryReference MAS Trade dataElement "23" field "Identifier of the floating rate of leg 2"
        provision "Identifier of the rate used for leg 2 which are reset at predetermined intervals by reference to a market reference rate, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract ProductForTrade
    then filter
        IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract RateOption
    then extract item -> indexReferenceInformation -> indexId only-element
        as "23 Identifier of the floating rate of leg 2"

reporting rule NameOfTheFloatingRateOfLeg2 from TransactionReportInstruction: <"Name of the floating rate of leg 2">
    [regulatoryReference MAS Trade dataElement "24" field "Name of the Floating Rate of Leg 2"
        provision "Name of the rate used for leg 2 which are reset at predetermined intervals by reference to a market reference rate, where Identifer of the floating rate of leg 2 is not available."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract GetNameOfTheFloatingRateOfLeg2
        as "24 Name of the Floating Rate of Leg 2"

reporting rule SpreadOfLeg2Monetary from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference MAS Trade dataElement "25" field "Spread of Leg 2"
        provision "For leg 2 of the contract, where applicable, the spread on the floating rate index reference price of leg 2, or the difference between the reference prices of the two floating rate indexes."]
    filter IsAllowableAction
    then extract CDESpreadLeg2
    then extract
        if GetPriceNotation = PriceNotationEnum -> Monetary
        then MultiplyPrice(value, GetPriceNotation)
        as "25 Spread of Leg 2 (Monetary)"

reporting rule SpreadOfLeg2Decimal from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference MAS Trade dataElement "25" field "Spread of Leg 2"
        provision "For leg 2 of the contract, where applicable, the spread on the floating rate index reference price of leg 2, or the difference between the reference prices of the two floating rate indexes."]
    filter IsAllowableAction
    then extract CDESpreadLeg2
    then extract
        if (GetPriceNotation = PriceNotationEnum -> Percentage or GetPriceNotation = PriceNotationEnum -> Decimal)
        then MultiplyPrice(value, PriceNotationEnum -> Decimal)
        as "25 Spread of Leg 2 (Percentage)"

reporting rule SpreadOfLeg2Basis from TransactionReportInstruction: <"Spread of Leg 2">
    [regulatoryReference MAS Trade dataElement "25" field "Spread of Leg 2"
        provision "For leg 2 of the contract, where applicable, the spread on the floating rate index reference price of leg 2, or the difference between the reference prices of the two floating rate indexes."]
    filter IsAllowableAction
    then extract CDESpreadLeg2
    then extract
        if GetPriceNotation = PriceNotationEnum -> Basis
        then MultiplyPrice(value, GetPriceNotation)
        as "25 Spread of Leg 2 (Basis)"

reporting rule SpreadNotationOfLeg2 from TransactionReportInstruction: <"Spread notation of leg 2">
    [regulatoryReference MAS Trade dataElement "26" field "Spread notation of leg 2"
        provision "Manner in which 'Spread of leg 2' is expressed, where applicable."]
    filter IsAllowableAction
    then if CDESpreadLeg2NotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else CDESpreadLeg2NotationEnum
        as "26 Spread notation of leg 2"

reporting rule SpreadCurrencyOfLeg2 from TransactionReportInstruction: <"Spread Currency of Leg 2">
    [regulatoryReference MAS Trade dataElement "27" field "Spread Currency of Leg 2"
        provision "Currency in which 'Spread of leg 2' is denominated, where applicable."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if IsIRSwaption
        then CDESpread_InterestRate(InterestRateLeg2(UnderlierForProduct))
        else if IsCommoditySwap
        then CDESpread_Commodity(CommodityLeg2)
        else CDESpread_InterestRate(InterestRateLeg2)
    then extract price
    then filter IsPriceMonetary
    then extract unit -> currency
        as "27 Spread Currency of Leg 2"

/* ---------------------------------------------------------------------------------------------------------------- */

reporting rule OptionType from TransactionReportInstruction: <"Option Type">
    [regulatoryReference MAS Trade dataElement "28" field "Option type"
        provision "To denote the type of option, where applicable."]
    filter IsAllowableAction
    then extract
    ProductForEvent
    then extract UPIOptionType
        as "28 Option type"

reporting rule OptionStyle from TransactionReportInstruction: <"Option Style">
    [regulatoryReference MAS Trade dataElement "29" field "Option Style"
        provision "To indicate whether the option can be exercised on a fixed date or any time during the life of the contract, where applicable."]
    filter IsAllowableAction
    then extract
    ProductForEvent
    then extract
        if IsFloor or IsCap
        then "EURO"
        else if IsOption
        then (EconomicTermsForProduct  -> payout -> optionPayout only-element -> exerciseTerms -> optionStyle 
            extract
                if americanExercise exists
                then "AMER"
                else if europeanExercise exists
                then "EURO"
                else if bermudaExercise exists
                then "BERM")
        as "29 Option Style"

reporting rule FirstExerciseDate from TransactionReportInstruction: <"First Exercise Date">
    [regulatoryReference MAS Trade dataElement "30" field "First Exercise Date"
        provision "First unadjusted date during the exercise period in which an option can be exercised, where applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
    then CDEFirstExerciseDate
        as "30 First exercise date"

reporting rule EffectiveDate from TransactionReportInstruction: <"Effective Date">
    [regulatoryReference MAS Trade dataElement "31" field "Effective Date"
        provision "Unadjusted date at which obligations under the contract come into effect."]
    filter IsAllowableAction
    then extract
             if Qualify_InterestRate_Fra (ProductForEvent -> contractualProduct -> economicTerms)
                 then (
                 if TradeForEvent exists then TradeForEvent -> tradeDate
                 else if PositionForEvent exists then PositionForEvent -> openDateTime -> date)
        else CDEEffectiveDate
        as "31 Effective Date"

reporting rule ExpirationDate from TransactionReportInstruction: <"Expiration Date">
    [regulatoryReference MAS Trade dataElement "32" field "Expiration Date"
        provision "Unadjusted date at which obligations under the contract stop being effective."]
    filter IsAllowableAction
    then extract GetExpirationDate
        as "32 Expiration Date"

reporting rule SwapLinkID from TransactionReportInstruction: <"Swap link ID">
    [regulatoryReference MAS Trade dataElement "33" field "Swap link ID"
        provision "The identifier that links both legs of a foreign exchange swap, where applicable."]
    filter IsAllowableAction and Qualify_ForeignExchange_Spot_Forward(ProductForEvent -> contractualProduct -> economicTerms)
    then extract GetPackageInformation
    then extract CDEPackageIdentifier
    then only-element
        as "33 Swap link ID"

reporting rule PackageIdentifier from TransactionReportInstruction: <"Package identifier">
    [regulatoryReference MAS Trade dataElement "34" field "Package identifier"
        provision "The identifier (determined by the reporting counterparty) in order to connect two or more derivatives contracts in the same package (other than a foreign exchange swap), where applicable."]
    filter IsAllowableAction
    then extract GetPackageInformation
    then extract CDEPackageIdentifier
    then only-element
        as "34 Package identifier"

reporting rule DeliveryType from TransactionReportInstruction:
    [regulatoryReference MAS Trade dataElement "35" field "Delivery type"
        provision "To indicate whether the contract is settled physically or in cash."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract DeliveryTypeForProducts
        as "35 Delivery Type"

// ToDo Note also we don't have Bond Forward, Equity Forward examples yet.
// ToDo - Credit Options are inconsistent & use settlementType - awaiting clarification on harmonisation potential before coding (and in any case, no DRR examples yet!)
// ToDo Commodities also likely to have other nuances?
//TODO: Add Equity Swap Samples to test this part of the code

reporting rule SettlementCurrency1 from TransactionReportInstruction: <"Settlement Currency 1">
    [regulatoryReference MAS Trade dataElement "36" field "Settlement currency 1"
        provision "For multicurrency contracts that do not net, the settlement currency of leg 1. For all other contracts, the currency for the cash settlement of the contract, where applicable."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract SettlementTermsLeg1
    then extract CDESettlementCurrency
        as "36 Settlement Currency 1"

reporting rule SettlementCurrency2 from TransactionReportInstruction: <"Settlement Currency 2">
    [regulatoryReference MAS Trade dataElement "37" field "Settlement currency 2"
        provision "For multicurrency contracts that do not net, the cash settlement currency of leg 2, where applicable."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract SettlementTermsLeg2
    then CDESettlementCurrency
        as "37 Settlement Currency 2"

reporting rule FinalContractualSettlementDate from TransactionReportInstruction: <"Final Contractual Settlement Date">
    [regulatoryReference MAS Trade dataElement "38" field "Final contractual settlement date"
        provision "Unadjusted date as per the contract, by which all transfer of cash or assets should take place and the counterparties should no longer have any outstanding obligations to each other under that contract."]
    filter IsAllowableAction
    then extract
        if Qualify_InterestRate_Fra(
                    TradeForEvent -> tradableProduct -> product -> contractualProduct -> economicTerms
                )
        then InterestRateLeg2(ProductForTrade(TradeForEvent)) -> paymentDate -> unadjustedDate
        else CDEFinalContractualSettlementDate(ProductForEvent)
        as "38 Final Contractual Settlement Date"

reporting rule Cleared from TransactionReportInstruction: <"Cleared">
    [regulatoryReference MAS Trade dataElement "39" field "Cleared"
        provision "Indicator of whether the contract has been cleared, or is intended to be cleared, by a central counterparty."]
    filter IsAllowableAction
    then CDECleared
        as "39 Cleared"

reporting rule CentralCounterparty from TransactionReportInstruction: <"Central Counterparty">
    [regulatoryReference MAS Trade dataElement "40" field "Central counterparty"
        provision "Identifier of the central counterparty that cleared the contract, where applicable."]
    filter IsAllowableAction
    then CDECentralCounterparty
        as "40 Central Counterparty"

reporting rule ClearingMember from TransactionReportInstruction: <"Clearing member">
    [regulatoryReference MAS Trade dataElement "41" field "Clearing member"
        provision "Identifier of the clearing member through which a contract was cleared at a central counterparty, where applicable."]
    filter IsAllowableAction
    then extract CDEClearingMember
        as "41 Clearing member"

reporting rule ClearingTimestamp from TransactionReportInstruction: <"Clearing Timestamp">
    [regulatoryReference MAS Trade dataElement "42" field "Clearing Timestamp"
        provision "The date when the clearing of the contract took place, where applicable."]
    filter IsAllowableAction
    then extract originatingWorkflowStep -> timestamp
    then filter qualification = EventTimestampQualificationEnum -> clearingDateTime
    then only-element
    then extract dateTime
        as "42 Clearing Timestamp"

reporting rule PlatformIdentifier from TransactionReportInstruction: <"Platform Identifier">
    [regulatoryReference MAS Trade dataElement "43" field "Platform Identifier"
        provision "Identifier of the trading facility on which the contract was executed."]
    filter IsAllowableAction 
    then CDEPlatformIdentifier
        as "43 Platform Identifier"

reporting rule ReportingObligationOfSpecifiedPerson from TransactionReportInstruction: <"Reporting obligation of specified person">
    [regulatoryReference MAS Trade dataElement "44" field "Reporting obligation of specified person"
        provision "To indicate the jurisdiction(s), other than Singapore, to which the specified person has a reporting obligation, where applicable."]
    [regulatoryReference MAS Trade dataElement "44" field "Reporting obligation of specified person - Explanatory notes (27 Nov)"
        provision "MAS currently does not expect specified persons to report this field. Further guidance on any change to this will be proivded in the future."]
    [regulatoryReference MAS PeerReviewGroup date "20240221"
        provision "MAS has specified in their guidelines (amended on 27 Nov) as well as their FAQ (Q4.12 updated on 15 Feb) that it does not expect specified persons to report this data field."]
    extract "Not Modelled"
        as "44 Reporting obligation of specified person"

reporting rule BookingLocation from TransactionReportInstruction: <"Booking location">
    [regulatoryReference MAS Trade dataElement "45" field "Booking Location"
        provision "Where the contract is booked in Singapore, to use country code for Singapore SG. Where the contract is not booked in Singapore, to denote the country where the contract was booked."]
    filter IsAllowableAction
    then extract reportingSide -> reportingParty -> contactInformation -> address last -> country 
        as "45 Booking location"

reporting rule TraderLocation from TransactionReportInstruction: <"Trader location">
    [regulatoryReference MAS Trade dataElement "46" field "Trader location"
        provision "Where the contract is traded in Singapore, to use country code for Singapore SG. Where the contract is not traded in Singapore, to denote the country where the trader which executed the contract is located."]
    filter IsAllowableAction
    then extract reportInstruction [
        reportableInformation -> partyInformation
            then filter partyReference = reportInstruction -> reportingSide -> reportingParty
            then only-element
    ]
    then filter relatedPerson -> role any = NaturalPersonRoleEnum -> Trader
    then extract relatedPerson -> personReference -> personId -> country 
    only-element
        as "46 Trader location"

reporting rule Confirmed from TransactionReportInstruction: <"Confirmed">
    [regulatoryReference MAS Trade dataElement "47" field "Confirmed"
        provision "To indicate whether the legally binding terms of a contract were documented and agreed upon (confirmed) or not (unconfirmed)."]
    filter IsAllowableAction
    then filter (IsCleared(originatingWorkflowStep) = False)
    then extract CDEConfirmed
        as "47 Confirmed"

reporting rule ConfirmationTimestamp from TransactionReportInstruction: <"Confirmation Timestamp">
    [regulatoryReference MAS Trade dataElement "48" field "Confirmation Timestamp"
        provision "The date when the contract is confirmed, where applicable."]
    filter IsAllowableAction 
    then extract
        if IsCleared(originatingWorkflowStep) = False
        then originatingWorkflowStep -> timestamp
    then filter qualification = EventTimestampQualificationEnum -> confirmationDateTime
    then distinct only-element
    then extract dateTime
        as "48 Confirmation Timestamp"

reporting rule ExecutionTimestamp from TransactionReportInstruction: <"Execution Timestamp">
    [regulatoryReference MAS Trade dataElement "49" field "Execution Timestamp"
        provision "Date and time a contract was originally executed, resulting in the generation of a new UTI."]
    filter IsAllowableAction or IsActionTypeTERM
    then CDEExecutionTimestamp
        as "49 Execution Timestamp"

reporting rule ReportingTimestamp from TransactionReportInstruction: <"Reporting Timestamp">
    [regulatoryReference MAS Trade dataElement "50" field "Reporting timestamp"
        provision "Date and time when the contract was reported to the trade repository."]
    CDEReportingTimestamp
        as "50 Reporting Timestamp"

reporting rule BasketConstituents from TransactionReportInstruction: <"Basket's Constituents">
    [regulatoryReference MAS Trade dataElement "51-52" field "Basket's constituents"
        provision "Field 18 is repeatable and shall be populated in case there is a basket with constituents"]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract GetBasketConstituentsProductIdentifier
    then extract
        BasketConstituentsReport {
            identifier: IdentifierOfBasketConstituents,
            source: SourceOfTheIdentifierOfTheBasketConstituents
        }

reporting rule IdentifierOfBasketConstituents from ProductIdentifier: <"Identifier of the basket's constituents">
    [regulatoryReference MAS Trade dataElement "51" field "Identifier of the basket's constituents"
        provision "Underliers that represent the constituents of a custom basket, where applicable."]
    extract identifier
        as "51/52-$ 51 Identifier of the basket's constituents"

reporting rule SourceOfTheIdentifierOfTheBasketConstituents from ProductIdentifier: <"Source of the identifier of the basket constituents">
    [regulatoryReference MAS Trade dataElement "52" field "Source of the identifier of the basket constituents"
        provision "Source of the underliers identifiers that represent the constituents of a custom basket, where applicable."]
    extract source
        as "51/52-$ 52 Source of the identifier of the basket constituents"


reporting rule ValuationAmount from TransactionReportInstruction: <"Valuation amount">
    [regulatoryReference MAS Trade dataElement "53" field "Valuation amount"
        provision "Current monetary value of the outstanding contract."]
    filter IsActionTypeVALU
    then CDEValuationAmount
        as "53 Valuation amount"

reporting rule ValuationCurrency from TransactionReportInstruction: <"Valuation currency">
    [regulatoryReference MAS Trade dataElement "54" field "Valuation currency"
        provision "Currency in which Valuation amount is denominated."]
    filter IsActionTypeVALU
    then CDEValuationCurrency
        as "54 Valuation currency"

reporting rule ValuationMethod from TransactionReportInstruction: <"Valuation method">
    [regulatoryReference MAS Trade dataElement "55" field "Valuation method"
        provision "Source and method used for the valuation of the contract by the Reporting specified person."]
    filter IsActionTypeVALU
    then extract CDEValuationMethod(GetValuation)
    to-string to-enum ValuationType1Code
        as "55 Valuation method"

reporting rule ValuationTimestamp from TransactionReportInstruction: <"Valuation Timestamp">
    [regulatoryReference MAS Trade dataElement "56" field "Valuation timestamp"
        provision "Date and time of the last valuation, whether by 'mark-to-market', 'mark-to-model' or provided by the central counterparty, as the case may be."]
    filter IsActionTypeVALU
    then CDEValuationTimestamp
        as "56 Valuation Timestamp"

reporting rule CollateralPortfolioIndicator from TransactionReportInstruction: <"Collateral Portfolio Indicator">
    [regulatoryReference MAS Trade dataElement "57" field "Collateral Portfolio Indicator"
        provision "Indicator of whether the collateralisation was performed on a portfolio basis."]
    filter IsAllowableAction
    then extract CDECollateralPortfolioIndicator
        as "57 Collateral Portfolio Indicator"

reporting rule InitialMarginCollateralPortfolioCodeDTCC from TransactionReportInstruction: <"Initial margin collateral portfolio code (DTCC)">
    [regulatoryReference MAS Trade dataElement "58" field "Initial margin collateral portfolio code (DTCC)"
        provision "Unique code assigned by Counterparty 1 to the portfolio when collateral is reported on a portfolio basis, where applicable."]
    extract TradeForEvent -> collateral -> collateralPortfolio
    then filter
        legalAgreement -> legalAgreementIdentification -> agreementName -> creditSupportAgreementMarginType = CollateralMarginTypeEnum -> InitialMargin
    then only-element
    then portfolioIdentifier -> assignedIdentifier -> identifier last
        as "58.1 Initial margin collateral portfolio code (DTCC)"

reporting rule VariationMarginCollateralPortfolioCodeDTCC from TransactionReportInstruction: <"Variation margin collateral portfolio code (DTCC)">
    [regulatoryReference MAS Trade dataElement "58" field "Initial margin collateral portfolio code (DTCC)"
        provision "Unique code assigned by Counterparty 1 to the portfolio when collateral is reported on a portfolio basis, where applicable."]
    extract TradeForEvent -> collateral -> collateralPortfolio
    then filter
        legalAgreement -> legalAgreementIdentification -> agreementName -> creditSupportAgreementMarginType = CollateralMarginTypeEnum -> VariationMargin
    then only-element
    then portfolioIdentifier -> assignedIdentifier -> identifier last
        as "58.2 Variation margin collateral portfolio code (DTCC)"

reporting rule NotionalAmountOfTheContractOrLeg1 from TransactionReportInstruction: <"Notional amount of the contract or leg 1">
    [regulatoryReference MAS Trade dataElement "76" field "Notional amount of the contract or leg 1"
        provision "The notional amount of the contract or leg 1 of the contract."]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // Commodity Option
                if IsCommodityOption(ProductForTrade)
                then (
                    if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice exists 
                    then CDECommodityOptionNotional(
                            tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                        )
                    else if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> averagingStrikeFeature exists 
                    then (
                        if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                        then CDECommodityNotional(
                                tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule,
                                LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                            )
                    else (
                        tradableProduct -> tradeLot -> priceQuantity only-element -> quantity
                        filter unit -> currency exists
                        then extract value
                        then only-element)
                    )
                )
                // Credit swaption
                else if IsCreditSwaption(ProductForTrade)
                then CDECreditNotional(
                            UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // FX forward and option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then CDEFXNotional(FXLeg1(ProductForTrade))
                // IR Swaption
                else if Qualify_InterestRate_Option_Swaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then CDEInterestRateNotional(
                            InterestRateLeg1(UnderlierForProduct(ProductForTrade))
                        )
                // Equity options
                else if IsEquityOption(ProductForTrade)
                then CDEEquityOptionNotional( EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout )

                // Equity forwards
                else if IsEquityForward(ProductForTrade)
                then CDEEquityForwardNotional( EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout )

                // Equity
                else if IsEquity(ProductForTrade)
                then CDEPerformanceNotional(
                            EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout
                        )
                // Credit
                else if IsCreditDefaultSwap(ProductForTrade)
                then CDECreditNotional(
                            tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // Commodity fixed/float swaps
                else if Qualify_Commodity_Swap_FixedFloat(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then CDECommodityNotional(
                            FixedPriceLeg1(tradableProduct -> product) -> priceQuantity -> quantitySchedule,
                            FixedPriceLeg1(tradableProduct -> product) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_FixedFloat(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then CDECommodityNotional(
                            FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> priceQuantity -> quantitySchedule,
                            FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_Basis(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                    then CDECommodityNotional(
                                CommodityBasisLegWithNoSpread(ProductForTrade) -> priceQuantity -> quantitySchedule,
                                LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                            )
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(UnderlierForProduct(ProductForTrade))
                        ) -> quantity
                        filter unit -> currency exists
                        then extract value
                        then only-element))
                // Commodity Basis
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                    then CDECommodityNotional(
                                CommodityBasisLegWithNoSpread(ProductForTrade) -> priceQuantity -> quantitySchedule,
                                LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                            )
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract value
                        then only-element))
                // ZCS Known Amount
                else if IsFixedFloatZeroCouponSwapKnownAmount(ProductForTrade)
                then CDEInterestRateNotional(
                            InterestRateLeg2FixedFloatSingleCurrency(ProductForTrade)
                        )
                // IR Swap
                else if Qualify_AssetClass_InterestRate(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then CDEInterestRateNotional(InterestRateLeg1(ProductForTrade))
    ]
        as "76 Notional amount of the contract or leg 1"

reporting rule NotionalCurrencyOfTheContractOrLeg1 from TransactionReportInstruction: <"Notional currency of the contract or leg 1">
    [regulatoryReference MAS Trade dataElement "77" field "Notional currency of the contract or leg 1"
        provision "Currency in which 'Notional amount of the contract or leg 1' is denominated."]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // Commodity Option
                if IsCommodityOption(ProductForTrade)
                then (
                    if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice exists 
                    then CDEOptionNotionalCurrency(
                            tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element
                        )
                    else if tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> strike -> averagingStrikeFeature exists 
                    then (
                        if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                        then LastAvailableSpotPrice(reportableEvent -> reportableInformation) -> unit -> currency
                    else (
                        tradableProduct -> tradeLot -> priceQuantity only-element -> quantity
                        filter unit -> currency exists
                        then extract unit -> currency
                        then only-element)
                    )
                )
                // Credit swaption
                else if Qualify_CreditDefaultSwaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        )
                then CDECreditNotionalCurrency(
                            UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // FX forward and option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then CDEFXNotionalCurrency(FXLeg1(ProductForTrade))
                // IR Swaption
                else if Qualify_InterestRate_Option_Swaption(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then CDEInterestRateNotionalCurrency(
                            InterestRateLeg1(UnderlierForProduct(ProductForTrade))
                        )
                // Equity options or Interest Rate Debt Option
                // Monetary quantity schedule
                else if (IsEquityOption(ProductForTrade) or IsInterestRateDebtOption(ProductForTrade))
                        and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency exists
                then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency
                // Equity options or Interest Rate Debt Option
                // Non-monetary quantity schedule
                else if (IsEquityOption(ProductForTrade) or IsInterestRateDebtOption(ProductForTrade))
                        and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
                then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> exerciseTerms -> strike -> strikePrice -> unit -> currency
                // Equity forwards
                else if IsEquityForward(ProductForTrade)
                then (
                    if EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency exists
                    then EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> currency
                    else EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> priceSchedule only-element -> unit -> currency
                )
                // Equity
                else if IsEquity(ProductForTrade)
                then CDEPerformanceNotionalCurrency(
                            EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout
                        )
                // Credit
                else if IsCreditDefaultSwap(ProductForTrade)
                then CDECreditNotionalCurrency(
                            tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout
                        )
                // Commodity fixed/float swaps
                else if Qualify_Commodity_Swap_FixedFloat(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then CDECommodityNotionalCurrency(
                            FixedPriceLeg1(tradableProduct -> product) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_FixedFloat(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then CDECommodityNotionalCurrency(
                            FixedPriceLeg1(UnderlierForProduct(tradableProduct -> product)) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swaption(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                        and Qualify_Commodity_Swap_Basis(
                                UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                            )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                    then LastAvailableSpotPrice(reportableEvent -> reportableInformation) -> unit -> currency
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract unit -> currency
                        then only-element))
                // Commodity Basis
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                    then LastAvailableSpotPrice(reportableEvent -> reportableInformation) -> unit -> currency
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract unit -> currency
                        then only-element))
                // ZCS Known Amount
                else if IsFixedFloatZeroCouponSwapKnownAmount(ProductForTrade)
                then CDEInterestRateNotionalCurrency(
                            InterestRateLeg2FixedFloatSingleCurrency(ProductForTrade)
                        )
                // IR Swap
                else if Qualify_AssetClass_InterestRate(
                            ProductForTrade -> contractualProduct -> economicTerms
                        ) = True
                then CDEInterestRateNotionalCurrency(InterestRateLeg1(ProductForTrade))
    ]
    then extract to-enum ISOCurrencyCodeEnum
        as "77 Notional currency of the contract or leg 1"

reporting rule NotionalAmountOfLeg2 from TransactionReportInstruction: <"Notional amount of leg 2">
    [regulatoryReference MAS Trade dataElement "78" field "Notional amount of leg 2"
        provision "The notional amount of leg 2 of the contract, where applicable."]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // Swaption
                if Qualify_InterestRate_Option_Swaption(
                                ProductForTrade -> contractualProduct -> economicTerms
                            ) = True
                then CDEInterestRateNotional(
                            InterestRateLeg2(UnderlierForProduct(ProductForTrade))
                        )
                // FX Forward and option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then CDEFXNotional(FXLeg2(ProductForTrade))
                // Commodity Fixed/Float Swap
                else if Qualify_Commodity_Swap_FixedFloat(
                            ProductForTrade -> contractualProduct -> economicTerms
                        )
                then CDECommodityNotional(
                            CommodityLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule,
                            FixedPriceLeg1(ProductForTrade) -> fixedPrice -> price
                        )
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                    then CDECommodityNotional(
                                CommodityBasisLegWithNoSpread(ProductForTrade) -> priceQuantity -> quantitySchedule,
                                LastAvailableSpotPrice(reportableEvent -> reportableInformation)
                            )
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg2(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract value
                        then only-element))
                // IR Swap, CDS, EQS
                else if Qualify_AssetClass_InterestRate(
                            EconomicTermsForProduct(tradableProduct -> product)
                        )
                        or Qualify_AssetClass_Equity(
                                EconomicTermsForProduct(tradableProduct -> product)
                            )
                then CDEInterestRateNotional(InterestRateLeg2(ProductForTrade))
    ]
        as "78 Notional amount of leg 2"

reporting rule NotionalCurrencyOfLeg2 from TransactionReportInstruction: <"Notional currency of leg 2">
    [regulatoryReference MAS Trade dataElement "79" field "Notional currency of leg 2"
        provision "Currency in which 'Notional amount of leg 2' is denominated, where applicable."]
    filter IsAllowableAction
    then extract reportableEvent [
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
            then extract
                // IR Swaption and Credit Swaption
                if Qualify_InterestRate_Option_Swaption(
                                ProductForTrade -> contractualProduct -> economicTerms
                            ) = True
                then CDEInterestRateNotionalCurrency(
                            InterestRateLeg2(UnderlierForProduct(ProductForTrade))
                        )
                // FX Forward and FX Option
                else if IsFXForward(ProductForTrade) or IsFXOption(ProductForTrade)
                then CDEFXNotionalCurrency(FXLeg2(ProductForTrade))
                // Commodity fixed/float swaps
                else if Qualify_Commodity_Swap_FixedFloat(
                            ProductForTrade -> contractualProduct -> economicTerms
                        )
                then FixedPriceLeg1(ProductForTrade) -> fixedPrice -> price -> unit -> currency
                else if Qualify_Commodity_Swap_Basis(
                            tradableProduct -> product -> contractualProduct -> economicTerms
                        )
                then (if LastAvailableSpotPrice(reportableEvent -> reportableInformation) exists
                    then LastAvailableSpotPrice(reportableEvent -> reportableInformation) -> unit -> currency
                    else (CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg2(ProductForTrade)
                        ) -> quantity
                        filter unit -> currency exists
                        then extract unit -> currency
                        then only-element))
                // IR, Credit and EQS
                else if Qualify_AssetClass_InterestRate(
                            EconomicTermsForProduct(tradableProduct -> product)
                        )
                        or Qualify_AssetClass_Equity(
                                EconomicTermsForProduct(tradableProduct -> product)
                            )
                then CDEInterestRateNotionalCurrency(InterestRateLeg2(ProductForTrade))
    ]
    then extract to-enum ISOCurrencyCodeEnum
        as "79 Notional currency of leg 2"

reporting rule TotalNotionalQuantityOfTheContractOrLeg1 from TransactionReportInstruction: <"Total notional quantity of the contract or leg 1">
    [regulatoryReference MAS Trade dataElement "80" field "Total notional quantity of the contract or leg 1"
        provision "Aggregate notional quantity of the underlying thing to the contract, for the term of the contract or for leg 1 of the contract, where applicable."]
    // todo: add coverage for equity swaps
    filter IsAllowableAction
    then extract TradeForEvent
    then extract
        if IsEquity(ProductForTrade) or IsEquityForward(ProductForTrade)
        then CDEEquityTotalNotionalQuantity(tradableProduct)
        else if IsCommoditySwapFloatFloat(ProductForTrade)
        then CDECommodityTotalNotionalQuantity(CommodityLeg1(ProductForTrade))
        else if IsCommoditySwapFixedFloat(ProductForTrade)
        then CDEFixedPriceTotalNotionalQuantity(FixedPriceLeg1(ProductForTrade))
        else if Qualify_Commodity_Swaption(
                    EconomicTermsForProduct(tradableProduct -> product)
                )
                and Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(UnderlierForProduct(ProductForTrade))
                    )
        then CDECommodityTotalNotionalQuantity(
                    CommodityLeg1(UnderlierForProduct(ProductForTrade))
                )
        else if Qualify_Commodity_Swaption(
                    EconomicTermsForProduct(tradableProduct -> product)
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        EconomicTermsForProduct(UnderlierForProduct(ProductForTrade))
                    )
        then CDEFixedPriceTotalNotionalQuantity(
                    FixedPriceLeg1(UnderlierForProduct(ProductForTrade))
                )
        else if Qualify_Commodity_Option(
                    EconomicTermsForProduct(tradableProduct -> product)
                )
        then CDEOptionTotalNotionalQuantity(
                    EconomicTermsForProduct(tradableProduct -> product) -> payout -> optionPayout only-element
                )
        as "80 Total notional quantity of the contract or leg 1"

reporting rule QuantityUnitOfMeasureForTheContractOrLeg1 from TransactionReportInstruction: <"Quantity unit of measure for the contract or leg 1">
    [regulatoryReference MAS Trade dataElement "81" field "Quantity unit of measure for the contract or leg 1"
        provision "Unit of measure in which 'Total notional quantity of the contract or leg 1' and 'Notional quantity of the contract or leg 1' are expressed, where applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then CommodityLeg1(ProductForTrade) -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                ) = True
        then EconomicTermsForProduct(ProductForTrade) -> payout -> fixedPricePayout only-element -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swaption(
                        tradableProduct -> product -> contractualProduct -> economicTerms
                    ) = True
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if Qualify_Commodity_Swaption(
                        tradableProduct -> product -> contractualProduct -> economicTerms
                    ) = True
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsCommodityOption(tradableProduct -> product)
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsEquityOption(ProductForTrade)
                and EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> optionPayout only-element -> priceQuantity -> quantitySchedule
        else if IsEquityForward(ProductForTrade) and EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> forwardPayout only-element -> priceQuantity -> quantitySchedule
        else if EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then EconomicTermsForProduct(ProductForTrade) -> payout -> performancePayout only-element -> priceQuantity -> quantitySchedule
    then extract CDEQuantityUnitOfMeasure
        as "81 Quantity unit of measure for the contract or leg 1"

reporting rule NotionalQuantityOfTheContractOrLeg1 from TransactionReportInstruction: <"Notional quantity of the contract or leg 1">
    [regulatoryReference MAS Trade dataElement "82" field "Notional quantity of the contract or leg 1"
        provision "The amount of the commodity (in quantity units) quoted on the contract or for leg 1 of the contract, where applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract trade [
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
        then [
                CommodityObservablePriceQuantity(
                        trade -> tradableProduct -> tradeLot only-element,
                        CommodityLeg1(ProductForTrade(trade))
                    )
            ]
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
        then trade -> tradableProduct -> tradeLot -> priceQuantity
            filter pq [ pq -> observable is absent ]
        else if Qualify_Commodity_Swaption(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade(trade)) -> contractualProduct -> economicTerms
                    )
        then [
                CommodityObservablePriceQuantity(
                        trade -> tradableProduct -> tradeLot only-element,
                        CommodityLeg1(UnderlierForProduct(ProductForTrade(trade)))
                    )
            ]
        else if Qualify_Commodity_Swaption(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade(trade)) -> contractualProduct -> economicTerms
                    )
        then trade -> tradableProduct -> tradeLot -> priceQuantity
            filter pq [ pq -> observable is absent ]
        else if Qualify_Commodity_Option(
                    ProductForTrade(trade) -> contractualProduct -> economicTerms
                )
        then trade -> tradableProduct -> tradeLot -> priceQuantity
    ]
    then extract quantity
    then flatten
    then filter frequency exists
    then extract quantitySchedule [
        if quantitySchedule -> value exists
        then quantitySchedule -> value
        else if quantitySchedule -> datedValue exists
                and quantitySchedule -> datedValue -> value distinct count = 1
        then quantitySchedule -> datedValue -> value first
    ]
    then distinct only-element
        as "82 Notional quantity of the contract or leg 1"

reporting rule QuantityFrequencyOfTheContractOrLeg1 from TransactionReportInstruction: <"Quantity frequency of the contract or leg 1">
    [regulatoryReference MAS Trade dataElement "83" field "Quantity frequency of the contract or leg 1"
        provision "The rate at which the quantity is quoted on the contract or for leg 1 of the contract (e.g. hourly, daily, weekly or monthly), where applicable."]
    [regulatoryReference MAS ISDAWorkingGroup date "20220607"
        provision "ONDE use case not supported. It was only found on physical commodities and they are out of scope for CFTC reporting."]
    //TH Jan 2024 - pending documentation/rationale reference
    extract TradeForEvent
    then extract
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriod(
                    CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(ProductForTrade)
                        ),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(ProductForTrade)
                                )
                        )
                )
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriod(
                    CommodityFixedPriceQuantity(tradableProduct -> tradeLot only-element),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriod(
                    CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg1(UnderlierForProduct(ProductForTrade))
                        ),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(UnderlierForProduct(ProductForTrade))
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriod(
                    CommodityFixedPriceQuantity(tradableProduct -> tradeLot only-element),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Option(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriod(
                    tradableProduct -> tradeLot -> priceQuantity only-element,
                    QuantityFrequencyOrCalculationPeriod(
                            ProductForTrade -> contractualProduct -> economicTerms -> payout -> optionPayout -> observationTerms -> calculationPeriodDates only-element,
                            tradableProduct -> tradeLot -> priceQuantity only-element
                        )
                )
        as "83 Quantity frequency of the contract or leg 1"

reporting rule QuantityFrequencyMultiplierOfTheContractOrLeg1 from TransactionReportInstruction: <"Quantity frequency multiplier of the contract or leg 1">
    [regulatoryReference MAS Trade dataElement "84" field "Quantity frequency multiplier of the contract or leg 1"
        provision "The number of time units for the 'Quantity frequency of the contract or leg 1', where applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract
        if Qualify_Commodity_Swap_Basis(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(ProductForTrade)
                                )
                        )
                )
        else if Qualify_Commodity_Swap_FixedFloat(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_Basis(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg1(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg1(UnderlierForProduct(ProductForTrade))
                                )
                        )
                )
        else if Qualify_Commodity_Swaption(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
                and Qualify_Commodity_Swap_FixedFloat(
                        UnderlierForProduct(ProductForTrade) -> contractualProduct -> economicTerms
                    )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(UnderlierForProduct(ProductForTrade)) -> calculationPeriodDates,
                            CommodityFixedPriceQuantity(
                                    tradableProduct -> tradeLot only-element
                                )
                        )
                )
        else if Qualify_Commodity_Option(
                    ProductForTrade -> contractualProduct -> economicTerms
                )
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            ProductForTrade -> contractualProduct -> economicTerms -> payout -> optionPayout -> observationTerms -> calculationPeriodDates only-element,
                            tradableProduct -> tradeLot -> priceQuantity only-element
                        )
                )
        as "84 Quantity frequency multiplier of the contract or leg 1"

reporting rule TotalNotionalQuantityOfLeg2 from TransactionReportInstruction: <"Total notional quantity of leg 2">
    [regulatoryReference MAS Trade dataElement "85" field "Total notional quantity of leg 2"
        provision "Aggregate notional quantity of the underlying thing for the term of leg 2 of the contract, where applicable."]
    // todo: add coverage for equity swaps
    filter IsAllowableAction
    then extract ProductForEvent
    then extract
        if IsCommoditySwap
        then CDECommodityTotalNotionalQuantity(CommodityLeg2)
        else if IsEquity and InterestRateLeg2 -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
        then (
            InterestRateLeg2 -> priceQuantity -> quantitySchedule
            then extract
            if multiplier exists
            then value * multiplier -> value
            else value
        )
        as "85 Total notional quantity of leg 2"

reporting rule QuantityUnitOfMeasureLeg2 from TransactionReportInstruction: <"Quantity Unit Of Measure Leg 2">
    [regulatoryReference MAS Trade dataElement "86" field "Quantity Unit Of Measure Leg 2"
        provision "Unit of measure in which 'Total notional quantity of leg 2' and 'Notional quantity of leg 2' are expressed, where applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
        then extract
            if IsCommoditySwap(tradableProduct -> product)
            then CommodityLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule
            else if IsEquity(ProductForTrade) and InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule -> unit -> financialUnit exists
            then InterestRateLeg2(ProductForTrade) -> priceQuantity -> quantitySchedule
        then extract CDEQuantityUnitOfMeasure
            as "86 Quantity Unit Of Measure Leg 2"

reporting rule NotionalQuantityOfLeg2 from TransactionReportInstruction: <"Notional quantity of leg 2">
    [regulatoryReference MAS Trade dataElement "87" field "Notional quantity of leg 2"
        provision "The amount of the commodity (in quantity units) quoted for leg 2 of the contract, where applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract trade [
        if IsCommoditySwap(ProductForTrade(trade))
        then CommodityObservablePriceQuantity(
                    trade -> tradableProduct -> tradeLot only-element,
                    CommodityLeg2(ProductForTrade(trade))
                )
    ]
    then extract quantity
    then filter frequency exists
    then extract quantitySchedule [
        if quantitySchedule -> value exists
        then quantitySchedule -> value
        else if quantitySchedule -> datedValue exists
                and quantitySchedule -> datedValue -> value distinct count = 1
        then quantitySchedule -> datedValue -> value first
    ]
    then distinct only-element
        as "87 Notional quantity of leg 2"

reporting rule QuantityFrequencyOfLeg2 from TransactionReportInstruction: <"Quantity frequency of leg 2">
    [regulatoryReference MAS Trade dataElement "88" field "Quantity frequency of leg 2"
        provision "The rate at which the quantity is quoted for leg 2 of the contract (e.g. hourly, daily, weekly or monthly), where applicable."]
    //TH Jan 2024 - pending documentation/rationale reference
    extract TradeForEvent
    then extract
        if IsCommoditySwap(ProductForTrade)
        then FrequencyPeriod(
                    CommodityObservablePriceQuantity(
                            tradableProduct -> tradeLot only-element,
                            CommodityLeg2(ProductForTrade)
                        ),
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg2(ProductForTrade)
                                )
                        )
                )
        as "88 Quantity frequency of leg 2"

reporting rule QuantityFrequencyMultiplierOfLeg2 from TransactionReportInstruction: <"Quantity frequency multiplier of leg 2">
    [regulatoryReference MAS Trade dataElement "89" field "Quantity frequency multiplier of leg 2"
        provision "The number of time units for the 'Quantity frequency of leg 2', where applicable."]
    filter IsAllowableAction
    then extract TradeForEvent
    then extract
        if IsCommoditySwap(ProductForTrade)
        then FrequencyPeriodMultiplier(
                    QuantityFrequencyOrCalculationPeriod(
                            CommodityLeg2(ProductForTrade) -> calculationPeriodDates,
                            CommodityObservablePriceQuantity(
                                    tradableProduct -> tradeLot only-element,
                                    CommodityLeg2(ProductForTrade)
                                )
                        )
                )
        as "89 Quantity frequency multiplier of leg 2"

reporting rule CallAmount from TransactionReportInstruction: <"Call Amount">
    [regulatoryReference MAS Trade dataElement "90" field "Call Amount"
        provision "Monetary amount that the option gives Counterparty 1 the right to buy, where applicable."]
    filter IsAllowableAction
    then extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then CDECallAmount
        as "90 Call amount"

reporting rule CallCurrency from TransactionReportInstruction: <"Call Currency">
    [regulatoryReference MAS Trade dataElement "91" field "Call Currency"
        provision "Currency in which Call amount is denominated, where applicable."]
    filter IsAllowableAction
    then CDECallCurrency
        then extract to-enum ISOCurrencyCodeEnum
        then only-element
        as "91 Call currency"

reporting rule PutAmount from TransactionReportInstruction: <"Put Amount">
    [regulatoryReference MAS Trade dataElement "92" field "Put Amount"
        provision "Monetary amount that the option gives Counterparty 1 the right to sell, where applicable."]
    filter IsAllowableAction
    then extract
        if IsActionTypeTERM
        then BeforeTradeForEvent
        else TradeForEvent
    then CDEPutAmount
    then only-element
        as "92 Put Amount"

reporting rule PutCurrency from TransactionReportInstruction: <"Put Currency">
    [regulatoryReference MAS Trade dataElement "93" field "Put Currency"
        provision "Currency in which 'Put amount' is denominated, where applicable."]
    filter IsAllowableAction
    then CDEPutCurrency
        then extract to-enum ISOCurrencyCodeEnum
        then only-element
        as "93 Put currency"

reporting rule PriceFormatMonetary from TransactionReportInstruction: <"Price">
    [regulatoryReference MAS Trade dataElement "94" field "Price"
        provision "Price specified in the contract, where applicable."]
    filter IsAllowableAction
    then extract
        if GetNotationEnum(CDEPriceNotation) = PriceNotationEnum -> Monetary
        then MultiplyPrice(CDEPrice, PriceNotationEnum -> Monetary)
        as "2.48 Price (Monetary)"

reporting rule PriceFormatDecimal from TransactionReportInstruction: <"Price">
    [regulatoryReference MAS Trade dataElement "94" field "Price"
        provision "Price specified in the contract, where applicable."]
    filter IsAllowableAction
    then extract
        if (GetNotationEnum(CDEPriceNotation) = PriceNotationEnum -> Percentage or GetNotationEnum(CDEPriceNotation) = PriceNotationEnum -> Decimal)
        then MultiplyPrice(CDEPrice, PriceNotationEnum -> Decimal)
        as "2.48 Price (Decimal)"

reporting rule PriceCurrency from TransactionReportInstruction: <"Price Currency">
    [regulatoryReference MAS Trade dataElement "95" field "Price currency"
        provision "Currency in which Price is denominated, where applicable."]
    filter IsAllowableAction
    then extract CDEPriceCurrency
    then extract to-enum ISOCurrencyCodeEnum
        as "95 Price currency"

reporting rule PriceNotation from TransactionReportInstruction: <"Price Notation Enum">
    [regulatoryReference MAS Trade dataElement "96" field "Price Notation"
        provision "Manner in which 'Price' is expressed, where applicable."]
    filter IsAllowableAction
    then if CDEPriceNotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else CDEPriceNotationEnum
    as "96 Price notation"

reporting rule PriceUnitOfMeasure from TransactionReportInstruction: <"Price Unit Of Measure">
    [regulatoryReference MAS Trade dataElement "97" field "Price Unit Of Measure"
        provision "Unit of measure in which 'Price' is expressed, where applicable."]
    filter IsAllowableAction
    then CDEPriceUnitOfMeasure
        as "97 Price unit of measure"

reporting rule ContractPriceSchedule from TransactionReportInstruction: <"Contract Price Schedule">
    [regulatoryReference MAS Trade dataElement "98-100" field "Contract Price Schedule"
        provision "Fields 98-100 are repeatable."]
    filter IsAllowableAction
    then extract GetReportablePricePeriod
    then extract
        PriceScheduleReport {
            effectiveDate: UnadjustedEffectiveDateOfThePrice,
            endDate: UnadjustedEndDateOfThePrice,
            priceMonetary: PriceInEffectBetweenTheUnadjustedEffectiveDateAndEndDateMonetary,
            priceDecimal: PriceInEffectBetweenTheUnadjustedEffectiveDateAndEndDateDecimal
        }

reporting rule UnadjustedEffectiveDateOfThePrice from PriceReportablePeriod: <"Unadjusted effective date of the price">
    [regulatoryReference MAS Trade dataElement "98" field "Unadjusted effective date of the price"
        provision "Unadjusted effective date of the price, where applicable."]
    CDEPriceScheduleEffectiveDate
        as "98/100-$ 98 Unadjusted effective date of the price"

reporting rule UnadjustedEndDateOfThePrice from PriceReportablePeriod: <"Unadjusted end date of the price">
    [regulatoryReference MAS Trade dataElement "99" field "Unadjusted end date of the price"
        provision "Unadjusted end date of the price, where applicable."]
    CDEPriceScheduleEndDate
        as "98/100-$ 99 Unadjusted end date of the price"

reporting rule PriceInEffectBetweenTheUnadjustedEffectiveDateAndEndDateMonetary from PriceReportablePeriod: <"Price in effect between the unadjusted effective and end date">
    [regulatoryReference MAS Trade dataElement "100" field "Price in effect between the unadjusted effective and end date"
        provision "Price in effect between the unadjusted effective date and unadjusted end date inclusive, where applicable."]
    CDEPriceScheduleAmountFormatMonetary
        as "98/100-$ 100 Price in effect between the unadjusted effective and end date (Monetary)"

reporting rule PriceInEffectBetweenTheUnadjustedEffectiveDateAndEndDateDecimal from PriceReportablePeriod: <"Price in effect between the unadjusted effective date and end date">
    [regulatoryReference MAS Trade dataElement "100" field "Price in effect between the unadjusted effective date and end date"
        provision "Price in effect between the unadjusted effective date and unadjusted end date inclusive, where applicable."]
    CDEPriceScheduleAmountFormatDecimal
        as "98/100-$ 100 Price in effect between the unadjusted effective and end date (Decimal)"

reporting rule StrikePriceMonetary from TransactionReportInstruction: <"Strike Price">
    [regulatoryReference MAS Trade dataElement "101" field "Strike Price"
        provision "The strike price of the option, where applicable."]
    filter IsAllowableAction
    then extract if GetNotationEnum(CDEStrikePriceNotation) = PriceNotationEnum -> Monetary
        then MultiplyPrice(CDEStrikePrice, GetNotationEnum(CDEStrikePriceNotation))
        as "101 Strike Price (Monetary)"

reporting rule StrikePriceDecimal from TransactionReportInstruction: <"Strike Price">
    [regulatoryReference MAS Trade dataElement "101" field "Strike Price"
        provision "The strike price of the option, where applicable."]
    filter IsAllowableAction
    then extract if (GetNotationEnum(CDEStrikePriceNotation) = PriceNotationEnum -> Percentage or GetNotationEnum(CDEStrikePriceNotation) = PriceNotationEnum -> Decimal)
        then MultiplyPrice(CDEStrikePrice, PriceNotationEnum -> Decimal)
        as "101 Strike Price (Decimal)"

reporting rule StrikePriceCurrencyCurrencyPair from TransactionReportInstruction: <"Strike price currency/currency pair">
    [regulatoryReference MAS Trade dataElement "102" field "Strike price currency/currency pair"
        provision "The currency or currency pair in which Strike price of the option is denominated or expressed, where applicable."]
    filter IsAllowableAction
    then CDEStrikePriceCurrency
        as "102 Strike price currency/currency pair"

reporting rule GetStrikePriceNotation from TransactionReportInstruction: <"Strike Price Notation Enum">
    [regulatoryReference MAS Trade dataElement "103" field "Strike Price Notation"
        provision "Manner in which 'Strike price' is expressed, where applicable."]
    filter IsAllowableAction
    then if CDEStrikePriceNotationEnum = PriceNotationEnum -> Percentage
    then PriceNotationEnum -> Decimal
    else CDEStrikePriceNotationEnum



//Repeatable fields modelling
reporting rule StrikePriceSchedule from TransactionReportInstruction: <"Strike Price Schedule">
    [regulatoryReference MAS Trade dataElement "104-106" field "Strike Price Schedule"
        provision "Fields 104-106 are repeatable."]
    filter IsAllowableAction
    then extract GetReportableStrikePricePeriod
    then extract
        StrikePriceScheduleReport {
            effectiveDate: EffectiveDateOfStrikePrice,
            endDate: EndDateOfStrikePrice,
            strikePriceInEffectOnAssociatedEffectiveDateMonetary: StrikePriceInEffectOnAssociatedEffectiveDateMonetary,
            strikePriceInEffectOnAssociatedEffectiveDateDecimal: StrikePriceInEffectOnAssociatedEffectiveDateDecimal,
            strikePriceNotationInEffectOnAssociatedEffectiveDate: StrikePriceNotationInEffectOnAssociatedEffectiveDate
        }

reporting rule EffectiveDateOfStrikePrice from PriceReportablePeriod: <"Effective date of strike price">
    [regulatoryReference MAS Trade dataElement "104" field "Effective date of strike price"
        provision "Unadjusted effective date of the strike price, where applicable."]
    CDEStrikePriceScheduleEffectiveDate
        as "104/106-$ 104 Effective date of strike price"

reporting rule EndDateOfStrikePrice from PriceReportablePeriod: <"End date of strike price">
    [regulatoryReference MAS Trade dataElement "105" field "End date of strike price"
        provision "Unadjusted end date of the strike price, where applicable."]
    CDEStrikePriceScheduleEndDate
        as "104/106-$ 105 End date of strike price"

reporting rule StrikePriceInEffectOnAssociatedEffectiveDateMonetary from PriceReportablePeriod: <"Strike price in effect on associated effective date">
    [regulatoryReference MAS Trade dataElement "106" field "Strike price in effect on associated effective date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive, where applicable."]
    CDEStrikePriceScheduleAmountFormatMonetary
        as "104/106-$ 106 Strike price in effect on associated effective date (Monetary)"

reporting rule StrikePriceInEffectOnAssociatedEffectiveDateDecimal from PriceReportablePeriod: <"Strike price in effect on associated effective date">
    [regulatoryReference MAS Trade dataElement "106" field "Strike price in effect on associated effective date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive, where applicable."]
    CDEStrikePriceScheduleAmountFormatDecimal
        as "104/106-$ 106 Strike price in effect on associated effective date (Decimal)"

reporting rule StrikePriceNotationInEffectOnAssociatedEffectiveDate from PriceReportablePeriod: <"Strike price notation in effect on associated effective date">
    [regulatoryReference MAS Trade dataElement "106" field "Strike price in effect on associated effective date"
        provision "Strike price in effect between the unadjusted effective date and unadjusted end date inclusive, where applicable."]
    extract periodValue -> priceNotation
        as "104/106-$ 106 Strike price notation in effect on associated effective date (Non Reportable)"

//End of repeatable fields
reporting rule OptionPremiumAmount from TransactionReportInstruction: <"Option premium amount">
    [regulatoryReference MAS Trade dataElement "107" field "Option premium amount"
        provision "Monetary amount paid by the option buyer, where applicable."]
    filter IsAllowableAction
    then CDEOptionPremiumAmount
        as "107 Option Premium Amount"

reporting rule OptionPremiumCurrency from TransactionReportInstruction: <"Option premium currency">
    [regulatoryReference MAS Trade dataElement "108" field "Option premium currency"
        provision "Currency in which Option premium amount is denominated, where applicable"]
    filter IsAllowableAction
    then CDEOptionPremiumCurrency
        as "108 Option Premium Currency"

reporting rule ExchangeRate from TransactionReportInstruction: <"Exchange Rate">
    [regulatoryReference MAS Trade dataElement "109" field "Exchange Rate"
        provision "Exchange rate between the two different currencies specified in the contract."]
    filter IsAllowableAction
    then CDEExchangeRate then extract value
        as "109 Exchange rate"

reporting rule ExchangeRateBasis from TransactionReportInstruction: <"Exchange Rate Basis">
    [regulatoryReference MAS Trade dataElement "110" field "Exchange Rate Basis"
        provision "Currency pair and order in which Exchange rate and Forward exchange rate, where applicable, is denominated."]
    filter IsAllowableAction
    then extract CDEExchangeRate
    then extract CDEExchangeRateBasis
        as "110 Exchange Rate Basis"

reporting rule FixedRateDayCountConventionOfLeg1 from TransactionReportInstruction: <"Fixed rate day count convention of leg 1">
    [regulatoryReference MAS Trade dataElement "111" field "Fixed rate day count convention of leg 1"
        provision "The actual number of days in the calculation period for the fixed rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then extract CDEDayCountConvention
    to-string to-enum InterestComputationMethod4Code
        as "111 Fixed rate day count convention of leg 1"

reporting rule FixedRateDayCountConventionOfLeg2 from TransactionReportInstruction: <"Fixed rate day count convention of leg 2">
    [regulatoryReference MAS Trade dataElement "112" field "Fixed rate day count convention of leg 2"
        provision "The actual number of days in the calculation period for the fixed rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then extract CDEDayCountConvention
    to-string to-enum InterestComputationMethod4Code
        as "112 Fixed rate day count convention of leg 2"

reporting rule FloatingRateDayCountConventionOfLeg1 from TransactionReportInstruction: <"Floating rate day count convention of leg 1">
    [regulatoryReference MAS Trade dataElement "113" field "Floating rate day count convention of leg 1"
        provision "The actual number of days in the calculation period for the floating rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract CDEDayCountConvention
    to-string to-enum InterestComputationMethod4Code
        as "113 Floating rate day count convention of leg 1"

reporting rule FloatingRateDayCountConventionOfLeg2 from TransactionReportInstruction: <"Floating rate day count convention of leg 2">
    [regulatoryReference MAS Trade dataElement "114" field "Floating rate day count convention of leg 2"
        provision "The actual number of days in the calculation period for the floating rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract CDEDayCountConvention
    to-string to-enum InterestComputationMethod4Code
        as "114 Floating rate day count convention of leg 2"

reporting rule FloatingRateResetFrequencyPeriodOfLeg1 from TransactionReportInstruction: <"Floating rate reset frequency period of leg 1">
    [regulatoryReference MAS Trade dataElement "115" field "Floating rate reset frequency period of leg 1"
        provision "Time unit associated with the frequency of resets of leg 1, where applicable."]
    [regulatoryReference ISDA PeerReviewGroup date "20231115"
        provision "The code ADHO is not supported on the basis that pertinent business scenarios remain unclear for this value and it has not been possible to elect the relevant logic. Further enhancements will be addressed once clear guidance or examples come forth."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    //TH Jan 2024 - pending documentation/rationale reference
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "115 Floating rate reset frequency period of leg 1"

reporting rule FloatingRateResetFrequencyPeriodMultiplierOfLeg1 from TransactionReportInstruction: <"Floating rate reset frequency period multiplier of leg 1">
    [regulatoryReference MAS Trade dataElement "116" field "Floating rate reset frequency period multiplier of leg 1"
        provision "Number of time units (as expressed by Floating rate reset frequency period of leg 1) that determines the frequency at which periodic payment dates for reset occur for the floating rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract resetDates -> resetFrequency -> periodMultiplier
        as "116 Floating rate reset frequency period multiplier of leg 1"

reporting rule FloatingRateResetFrequencyPeriodOfLeg2 from TransactionReportInstruction: <"Floating rate reset frequency period of leg 2">
    [regulatoryReference MAS Trade dataElement "117" field "Floating rate reset frequency period of leg 2"
        provision "Time unit associated with the frequency of resets of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    //TH Jan 2024 - pending documentation/rationale reference
    filter IsAllowableAction
    then extract ProductForEvent
    then filter
        IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then ResetFrequencyPeriod(resetDates -> resetFrequency)
        as "117 Floating rate reset frequency period of Leg 2"

reporting rule FloatingRateResetFrequencyPeriodMultiplierOfLeg2 from TransactionReportInstruction:
    [regulatoryReference MAS Trade dataElement "118" field "Floating rate reset frequency period multiplier of leg 2"
        provision "Number of time units (as expressed by Floating rate reset frequency period of leg 2) that determines the frequency at which periodic payment dates for reset occur for the floating rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then filter
        IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then extract
        if rateSpecification -> floatingRate exists
                or rateSpecification -> inflationRate exists
        then resetDates -> resetFrequency -> periodMultiplier
        as "118 Floating rate reset frequency period multiplier of leg 2"

reporting rule FixedRatePaymentFrequencyPeriodOfLeg1 from TransactionReportInstruction: <"Fixed rate payment frequency period of leg 1">
    [regulatoryReference MAS Trade dataElement "119" field "Fixed rate payment frequency period of leg 1"
        provision "Time unit associated with the frequency of payments for Fixed rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    //TH Jan 2024 - pending documentation/rationale reference
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then CDEPaymentFrequencyPeriod
    to-string to-enum Frequency13Code__1
        as "119 Fixed rate payment frequency period of leg 1"

reporting rule FixedRatePaymentFrequencyPeriodMultiplierOfLeg1 from TransactionReportInstruction: <"Fixed rate payment frequency period multiplier of leg 1">
    [regulatoryReference MAS Trade dataElement "120" field "Fixed rate payment frequency period multiplier of leg 1"
        provision "Number of time units (as expressed by Fixed rate payment frequency period of leg 1) that determines the frequency at which periodic payment dates occur for Fixed rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter rateSpecification -> fixedRate exists
    then CDEPaymentFrequencyPeriodMultiplier
        as "120 Fixed rate payment frequency period multiplier of leg 1"

reporting rule FixedRatePaymentFrequencyPeriodOfLeg2 from TransactionReportInstruction: <"Fixed rate payment frequency period of leg 2">
    [regulatoryReference MAS Trade dataElement "121" field "Fixed rate payment frequency period of leg 2"
        provision "Time unit associated with the frequency of payments for Fixed rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    //TH Jan 2024 - pending documentation/rationale reference
    extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then CDEPaymentFrequencyPeriod
    to-string to-enum Frequency13Code__1
        as "121 Fixed rate payment frequency period of leg 2"

reporting rule FixedRatePaymentFrequencyPeriodMultiplierOfLeg2 from TransactionReportInstruction: <"Fixed rate payment frequency period multiplier of leg 2">
    [regulatoryReference MAS Trade dataElement "122" field "Fixed rate payment frequency period multiplier of leg 2"
        provision "Number of time units (as expressed by Fixed rate payment frequency period of leg 2) that determines the frequency at which periodic payment dates occur for the Fixed rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter rateSpecification -> fixedRate exists
    then CDEPaymentFrequencyPeriodMultiplier
        as "122 Fixed rate payment frequency period multiplier of leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodOfLeg1 from TransactionReportInstruction: <"Floating rate payment frequency period of leg 1">
    [regulatoryReference MAS Trade dataElement "123" field "Floating rate payment frequency period of leg 1"
        provision "Time unit associated with the frequency of payments for the floating rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    //TH Jan 2024 - pending documentation/rationale reference
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract CDEPaymentFrequencyPeriod to-enum Frequency13Code__1
        as "123 Floating rate payment frequency period of leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierOfLeg1 from TransactionReportInstruction: <"Floating rate payment frequency period multiplier of leg 1">
    [regulatoryReference MAS Trade dataElement "124" field "Floating rate payment frequency period multiplier of leg 1"
        provision "Number of time units (as expressed by Floating rate payment frequency period of leg 1) that determines the frequency at which periodic payment dates occur for the floating rate of leg 1, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Equity products are implicitly filtered out by calling the function InterestRateLeg1, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg1
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then CDEPaymentFrequencyPeriodMultiplier
        as "124 Floating rate payment frequency period multiplier of leg 1"

reporting rule FloatingRatePaymentFrequencyPeriodOfLeg2 from TransactionReportInstruction: <"Floating rate payment frequency period of leg 2">
    [regulatoryReference MAS Trade dataElement "125" field "Floating rate payment frequency period of leg 2"
        provision "Time unit associated with the frequency of payments for the floating rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    //TH Jan 2024 - pending documentation/rationale reference
    filter IsAllowableAction
    then extract ProductForEvent
    then filter IsFRA = False
    then extract
        if IsIRSwaption or IsCreditSwaption
        then InterestRateLeg2(UnderlierForProduct)
        else InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then extract CDEPaymentFrequencyPeriod to-enum Frequency13Code__1
        as "125 Floating rate payment frequency period of leg 2"

reporting rule FloatingRatePaymentFrequencyPeriodMultiplierOfLeg2 from TransactionReportInstruction: <"Floating rate payment frequency period multiplier of leg 2">
    [regulatoryReference MAS Trade dataElement "126" field "Floating rate payment frequency period multiplier of leg 2"
        provision "Number of time units (as expressed by the payment frequency period) that determines the frequency at which periodic payment dates occur for the floating rate of leg 2, where applicable."]
    [regulatoryReference ISDA TechnicalExecutionGroup date "20240418"
        provision "Credit products are implicitly filtered out by calling the function InterestRateLeg2, so no explicit filtering is needed."]
    filter IsAllowableAction
    then extract ProductForEvent
    then extract ProductOrUnderlierProduct
    then extract InterestRateLeg2
    then filter
        rateSpecification -> floatingRate exists
            or rateSpecification -> inflationRate exists
    then CDEPaymentFrequencyPeriodMultiplier
        as "126 Floating rate payment frequency period multiplier of leg 2"

// Repeatable Field modelling
reporting rule OtherPayment from TransactionReportInstruction: <"Other Payment">
    filter IsAllowableAction or IsActionTypeTERM
    then extract TradeStateForEvent
    then extract transferHistory
    then extract
        OtherPaymentReport {
            paymentType: OtherPaymentType,
            amount: OtherPaymentAmount,
            currency: OtherPaymentCurrency,
            payer: OtherPaymentPayer,
            payerFormat: OtherPaymentPayerFormat,
            receiver: OtherPaymentReceiver,
            receiverFormat: OtherPaymentReceiverFormat
        }

reporting rule OtherPaymentType from TransferState: <"Other payment type">
    [regulatoryReference MAS Trade dataElement "127" field "Other payment type"
        provision "Type of Other payment amount, where applicable."]
    filter IsOtherPayment
    then extract CDEOtherPaymentType to-enum PaymentType4Code
        as "127/131-$ 127 Other Payment Type"

reporting rule OtherPaymentAmount from TransferState: <"Other payment amount">
    [regulatoryReference MAS Trade dataElement "128" field "Other payment amount"
        provision "Other payment amount based on Other payment type, where applicable."]
    filter IsOtherPayment
    then extract CDEOtherPaymentAmount
        as "128/131-$ 128 Other Payment Amount"

reporting rule OtherPaymentCurrency from TransferState: <"Other payment currency">
    [regulatoryReference MAS Trade dataElement "129" field "Other payment currency"
        provision "Currency in which Other payment amount is denominated, where applicable."]
    filter IsOtherPayment
    then extract CDEOtherPaymentCurrency
        as "129/131-$ 129 Other Payment Currency"

reporting rule OtherPaymentPayer from TransferState: <"Other payment payer">
    [regulatoryReference MAS Trade dataElement "130" field "Other payment payer"
        provision "Identifier of the payer of Other payment amount, where applicable."]
    filter IsOtherPayment
    then extract CDEOtherPaymentPayer
        as "130/131-$ 130 Other Payment Payer"

reporting rule OtherPaymentPayerFormat from TransferState: <"Other Payment Payer Format">
    filter IsOtherPayment
    then extract CDEOtherPaymentPayerFormat
        as "130/131-$ 130 Other Payment Payer Format (non-reportable)"

reporting rule OtherPaymentReceiver from TransferState: <"Other payment receiver">
    [regulatoryReference MAS Trade dataElement "131" field "Other payment receiver"
        provision "Identifier of the receiver of Other payment amount, where applicable."]
    filter IsOtherPayment
    then extract CDEOtherPaymentReceiver
        as "131/131-$ 131 Other Payment Receiver"

reporting rule OtherPaymentReceiverFormat from TransferState: <"Other Payment Receiver Format">
    filter IsOtherPayment
    then extract CDEOtherPaymentReceiverFormat
        as "131/131-$ 131 Other Payment Receiver Format (non-reportable)"
// End of Repeatable Field modelling

reporting rule ActionType from TransactionReportInstruction: <"Action type">
    [regulatoryReference MAS Trade dataElement "132" field "Action type"
        provision "Type of action taken on the contract."]
    extract 
        if IsActionTypeCORR
        then ActionTypeEnum -> CORR to-string
        else if IsActionTypeEROR
        then ActionTypeEnum -> EROR to-string
        else if IsActionTypeREVI
        then ActionTypeEnum -> REVI to-string
        else if IsActionTypePRTO
        then ActionTypeEnum -> PRTO to-string
        else if IsActionTypeVALU
        then ActionTypeEnum -> VALU to-string
        else if IsActionTypeTERM
        then ActionTypeEnum -> TERM to-string
        else if IsActionTypeMODI
        then ActionTypeEnum -> MODI to-string
        else if IsActionTypeNEWT
        then ActionTypeEnum -> NEWT to-string
        else "ToDo"
        as "132 Action type"

reporting rule EventType from TransactionReportInstruction: <"Event Type">
    [regulatoryReference MAS Trade dataElement "133" field "Event Type"
        provision "Explanation or reason for the action being taken on the contract, where applicable."]
    //TH Jan 2024 - pending documentation/rationale reference
    /**
     *         4 alphabetic characters:
     * TRAD = Trade
     * NOVA = Step-in
     * COMP = PTRR
     * ETRM = Early termination
     * CLRG = Clearing
     * EXER = Exercise
     * ALOC = Allocation
     * CREV = Credit event
     * CORP = Corporate event
     * CLAL = Clearing & Allocation - ToDo
     * UPDT = Update
     **/
    filter (IsActionTypeNEWT or IsActionTypeMODI or IsActionTypeTERM)
    then extract reportableEvent [
        if (IsActionTypeCORR = False and
            IsActionTypeEROR = False and
            IsActionTypeREVI = False and
            IsActionTypeVALU = False)
        then originatingWorkflowStep
             extract workflowStep [
                if workflowStep -> businessEvent exists
                then
                    workflowStep -> businessEvent
                    extract
                        (if IsEventTypePTNG(reportableEvent) or IsActionTypePRTO(reportableEvent)
                        then EventTypeEnum -> PTNG to-string
                        else if IsEventTypeUPDT(reportableEvent)
                        then EventTypeEnum -> UPDT to-string
                        else if Qualify_Novation
                                    or Qualify_PartialNovation
                                    or intent = EventIntentEnum -> Novation
                            then EventTypeEnum -> NOVA to-string
                            else if Qualify_Allocation
                                    or Qualify_Reallocation
                                    or intent = EventIntentEnum -> Allocation
                            then EventTypeEnum -> ALOC to-string
                            else if Qualify_Exercise
                                    or intent = EventIntentEnum -> OptionExercise
                            then EventTypeEnum -> EXER to-string
                            else if Qualify_ClearedTrade
                                or reportableEvent -> originatingWorkflowStep -> workflowState -> workflowStatus = WorkflowStatusEnum -> Cleared
                                    or intent = EventIntentEnum -> Clearing
                            then EventTypeEnum -> CLRG to-string
                            else if Qualify_Compression or intent = EventIntentEnum -> Compression or Qualify_PortfolioRebalancing
                            then EventTypeEnum -> COMP to-string
                            else if Qualify_Termination or intent = EventIntentEnum -> EarlyTerminationProvision or Qualify_PartialTermination
                            then EventTypeEnum -> ETRM to-string
                            else if Qualify_CreditEventDetermined or intent = EventIntentEnum -> CreditEvent
                            then EventTypeEnum -> CREV to-string
                            else if Qualify_CorporateActionDetermined or intent = EventIntentEnum -> CorporateActionAdjustment
                            then EventTypeEnum -> CORP to-string
                            else if Qualify_ContractFormation
                                    or Qualify_Increase
                                    or Qualify_Renegotiation
                                    or Qualify_IndexTransition
                                    or Qualify_FullReturn
                                    or instruction -> primitiveInstruction -> quantityChange exists
                                    or instruction -> primitiveInstruction -> transfer exists
                                    or intent = EventIntentEnum -> ContractTermsAmendment
                            then EventTypeEnum -> TRAD to-string
                            else "ToDo")
        ]
     ]
        as "133 Event Type"

reporting rule EventDate from TransactionReportInstruction: <"Event Date">
    [regulatoryReference MAS Trade dataElement "134" field "Event date"
        provision "Date of occurrence of the event."]
    extract
        if originatingWorkflowStep -> businessEvent exists
        then originatingWorkflowStep -> businessEvent -> eventDate
        else originatingWorkflowStep -> counterpartyPositionBusinessEvent -> eventDate
        as "134 Event Date"

reporting rule TechnicalRecordId from TransactionReportInstruction: <"Technical Record Id (ISO)">
    [regulatoryReference MAS Trade dataElement "[Internal]" field "Technical Record Id (ISO)"
        provision "Unique technical identification of the original data for which the status is provided for the BDR."]
    extract reportableInformation -> partyInformation -> regimeInformation
    then filter reportingRole = ReportingRoleEnum -> ReportingParty and regimeName = RegimeNameEnum -> MAS
    then extract technicalRecordId
    then distinct only-element
        as "[Internal] Technical Record Id (ISO)"

reporting rule ExecutionAgentOfTheCounterparty1DTCC from TransactionReportInstruction: <"Execution agent of the Counterparty 1 (DTCC)">
    [regulatoryReference MAS Trade dataElement "[Not in regulation]" field "Execution agent of the Counterparty 1"
        provision "LEI of the entity that entered into the Reportable Transaction as agent for the Reporting Entity without becoming a counterparty themselves."]
    filter IsAllowableAction
    then extract
        ExtractPartyFromRelatedPartyByRole(
                reportableInformation -> partyInformation -> relatedParty,
                PartyRoleEnum -> ExecutionAgent
            )
    then extract PartyLei(partyId)
        as "[Not in regulation] Execution agent of the Counterparty 1 (DTCC)"

reporting rule Counterparty2NameDTCC from TransactionReportInstruction: <"Counterparty 2 name (DTCC)">
    [regulatoryReference MAS Trade dataElement "[Not in regulation]" field "Counterparty 2 name"
        provision "Legal name of the Counterparty 2 to the contract."]
    extract reportInstruction [
        extract 
            TradeForEvent(reportInstruction) -> tradableProduct -> counterparty -> partyReference        
        then filter item = reportInstruction -> reportingSide -> reportingCounterparty and item -> partyId -> identifierType any <> PartyIdentifierTypeEnum -> LEI
        then extract item -> name
        then only-element
    ]
        as "[Not in regulation] Counterparty 2 name (DTCC)"